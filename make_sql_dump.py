#!/usr/bin/env python3
from __future__ import annotations

import argparse
import gzip
import json
import math
from pathlib import Path
from typing import Any, Dict, Iterable, Optional, TextIO, Literal

Dialect = Literal["mariadb", "mysql"]

# ---------- SQL escaping helpers ----------

def sql_quote(s: str) -> str:
    """Quote string for MySQL/MariaDB single-quoted literal."""
    s = s.replace("\\", "\\\\")
    s = s.replace("\0", "\\0")
    s = s.replace("\n", "\\n")
    s = s.replace("\r", "\\r")
    s = s.replace("\t", "\\t")
    s = s.replace("\x1a", "\\Z")
    s = s.replace("'", "\\'")
    return f"'{s}'"


def sql_nullable_float(v: Any) -> str:
    if v is None:
        return "NULL"
    try:
        f = float(v)
    except Exception:
        return "NULL"
    if not math.isfinite(f):
        return "NULL"
    return repr(f)


def sql_int(v: Any) -> str:
    return str(int(v))


# ---------- JSON normalisation ----------

def _normalize_json(v: Any) -> Any:
    """
    Make value JSON-safe:
    - Convert NaN/Inf to strings
    - Convert numpy scalars -> python scalars
    - Recurse dict/list/tuple
    """
    if v is None:
        return None
    if isinstance(v, (str, bool, int)):
        return v

    if isinstance(v, float):
        if math.isnan(v):
            return "NaN"
        if v == math.inf:
            return "INF"
        if v == -math.inf:
            return "-INF"
        return v

    if not isinstance(v, (dict, list, tuple)):
        try:
            if isinstance(v, (bytes, bytearray)):
                return v.decode("utf-8", errors="replace")
            f = float(v)
            if math.isnan(f):
                return "NaN"
            if f == math.inf:
                return "INF"
            if f == -math.inf:
                return "-INF"
            try:
                i = int(v)
                if float(i) == f:
                    return i
            except Exception:
                pass
            return f
        except Exception:
            return str(v)

    if isinstance(v, dict):
        return {str(k): _normalize_json(vv) for k, vv in v.items()}

    if isinstance(v, (list, tuple)):
        return [_normalize_json(x) for x in v]

    return str(v)


def json_compact_mysql(v: Any) -> str:
    norm = _normalize_json(v)
    return json.dumps(
        norm,
        ensure_ascii=False,
        sort_keys=True,
        separators=(",", ":"),
        allow_nan=False,  # valid JSON
    )


def sql_json_value(v: Any, *, dialect: Dialect) -> str:
    """
    - mysql: CAST('...json...' AS JSON) to force validation
    - mariadb: just '...json...' (store text); JSON type/cast часто несовместимы
    """
    s = json_compact_mysql(v)
    if dialect == "mysql":
        return f"CAST({sql_quote(s)} AS JSON)"
    return sql_quote(s)


# ---------- IO helpers ----------

def iter_jsonl(path: Path) -> Iterable[Dict[str, Any]]:
    """Iterate JSON objects from .jsonl or .jsonl.gz"""
    if path.suffix == ".gz":
        with gzip.open(path, "rt", encoding="utf-8", newline="") as f:
            for line in f:
                line = line.strip()
                if line:
                    yield json.loads(line)
    else:
        with path.open("r", encoding="utf-8", newline="") as f:
            for line in f:
                line = line.strip()
                if line:
                    yield json.loads(line)


# ---------- Dump writer ----------

def write_preamble(out: TextIO, table: str, truncate: bool, *, dialect: Dialect) -> None:
    out.write("-- Generated by make_sql_dump.py\n")
    out.write("SET NAMES utf8mb4;\n")
    out.write("SET time_zone = '+00:00';\n")
    out.write("SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';\n\n")

    out.write(f"CREATE TABLE IF NOT EXISTS `{table}` (\n")
    out.write("  `key` VARCHAR(220) NOT NULL,\n")
    out.write("  `version` TINYINT UNSIGNED NOT NULL,\n")
    out.write("  `houseEdge` DOUBLE NULL,\n")
    out.write("  `houseEdgePct` DOUBLE NULL,\n")

    if dialect == "mysql":
        out.write("  `matrices` JSON NOT NULL,\n")
        out.write("  `rules` JSON NOT NULL,\n")
        out.write("  `meta` JSON NULL,\n")
    else:
        # MariaDB-safe (phpMyAdmin)
        out.write("  `matrices` MEDIUMTEXT NOT NULL,\n")
        out.write("  `rules` MEDIUMTEXT NOT NULL,\n")
        out.write("  `meta` MEDIUMTEXT NULL,\n")

    out.write("  PRIMARY KEY (`key`)\n")
    out.write(") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n")

    if truncate:
        out.write(f"TRUNCATE TABLE `{table}`;\n\n")


def write_insert_batch(out: TextIO, table: str, rows: list[Dict[str, Any]], *, dialect: Dialect) -> None:
    if not rows:
        return

    out.write(
        f"INSERT INTO `{table}` "
        "(`key`,`version`,`houseEdge`,`houseEdgePct`,`matrices`,`rules`,`meta`) VALUES\n"
    )

    values_sql: list[str] = []
    for obj in rows:
        key = str(obj["key"])
        version = int(obj.get("version", 2))
        he = obj.get("houseEdge", None)
        hep = obj.get("houseEdgePct", None)
        matrices = obj["matrices"]
        rules = obj["rules"]
        meta = obj.get("meta", None)

        values_sql.append(
            "("
            + ",".join(
                [
                    sql_quote(key),
                    sql_int(version),
                    sql_nullable_float(he),
                    sql_nullable_float(hep),
                    sql_json_value(matrices, dialect=dialect),
                    sql_json_value(rules, dialect=dialect),
                    "NULL" if meta is None else sql_json_value(meta, dialect=dialect),
                ]
            )
            + ")"
        )

    out.write(",\n".join(values_sql))
    out.write(";\n\n")


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--in", dest="inp", type=Path, required=True, help="Path to .jsonl or .jsonl.gz")
    ap.add_argument("--out", dest="out", type=Path, required=True, help="Output .sql path")
    ap.add_argument("--table", type=str, default="hoppe_strategies", help="Table name")
    ap.add_argument("--truncate", action="store_true", help="Add TRUNCATE TABLE before inserts")
    ap.add_argument("--batch", type=int, default=200, help="Rows per INSERT")
    ap.add_argument("--limit", type=int, default=0, help="Limit rows (0 = all)")
    ap.add_argument("--dialect", choices=["mariadb", "mysql"], default="mariadb", help="Target SQL dialect")

    args = ap.parse_args()
    inp: Path = args.inp
    outp: Path = args.out
    table: str = args.table
    dialect: Dialect = args.dialect  # type: ignore[assignment]

    if args.batch <= 0:
        raise SystemExit("--batch must be > 0")

    n_limit: Optional[int] = None if args.limit <= 0 else int(args.limit)

    count = 0
    batch: list[Dict[str, Any]] = []

    outp.parent.mkdir(parents=True, exist_ok=True)
    with outp.open("w", encoding="utf-8", newline="\n") as out:
        write_preamble(out, table=table, truncate=bool(args.truncate), dialect=dialect)

        for obj in iter_jsonl(inp):
            if "key" not in obj or "matrices" not in obj or "rules" not in obj:
                continue

            batch.append(obj)
            count += 1

            if len(batch) >= args.batch:
                write_insert_batch(out, table=table, rows=batch, dialect=dialect)
                batch = []

            if n_limit is not None and count >= n_limit:
                break

        write_insert_batch(out, table=table, rows=batch, dialect=dialect)
        out.write(f"-- Rows written: {count}\n")

    print(f"OK: wrote {count} rows into {outp} (dialect={dialect})")


if __name__ == "__main__":
    main()